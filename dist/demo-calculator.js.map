{"version":3,"file":"demo-calculator.js","sources":["../src/demo-calculator.js"],"sourcesContent":["/**\n * A tutorial application that shows how to build a calculator application\n * in JavaScript.\n */\nexport class CalculatorApp {\n  static get PLUS_SYMBOL() {\n    return '+';\n  }\n\n  static get MINUS_SYMBOL() {\n    return '-';\n  }\n\n  static get MULTIPLY_SYMBOL() {\n    return 'x';\n  }\n\n  static get DIVIDE_SYMBOL() {\n    return 'รท';\n  }\n\n  static get DOT_SYMBOL() {\n    return '.';\n  }\n  /**\n   * @return {Element} Reference to the formula parts dispay node.\n   */\n  get partsResult() {\n    if (!this.__partsResult) {\n      this.__partsResult = document.getElementById('partsResult');\n    }\n    return this.__partsResult;\n  }\n  /**\n   * @return {Element} Reference to the result dispay node.\n   */\n  get opResult() {\n    if (!this.__opResult) {\n      this.__opResult = document.getElementById('opResult');\n    }\n    return this.__opResult;\n  }\n\n  constructor() {\n    // Because scope in event listeners changes to the originating HTML element\n    // we bind current scope to the handler function.\n    this._actionHandler = this._actionHandler.bind(this);\n    this._mouseUpHandler = this._mouseUpHandler.bind(this);\n    this._keyDownHandler = this._keyDownHandler.bind(this);\n    // This is where the list of operations is kept.\n    this.queue = [];\n  }\n  /**\n   * Initializes the calculator app by attaching event listener to each button.\n   * This could be optymized by adding single event listener on a parent of all\n   * buttons but this is out of scope of this tutorial.\n   */\n  init() {\n    const nodes = document.querySelectorAll('button.action');\n    for (let i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].addEventListener('click', this._actionHandler);\n      nodes[i].addEventListener('mouseup', this._mouseUpHandler);\n    }\n    document.body.addEventListener('keydown', this._keyDownHandler);\n  }\n  /**\n   * Click event handler for all action buttons. It calls corresponding function\n   * depending on user selection. It looks for the `data-value` attribute for\n   * button's value which can be a numeric value if an operation.\n   * @param {ClickEvent} e\n   */\n  _actionHandler(e) {\n    // e.target is the button being clicked on\n    // target.dataset is a list of `data-*` attributes\n    // dataset.value is the `data-value=...` attribute's value.\n    const operation = e.target.dataset.value;\n    switch (operation) {\n      case 'add': this.add(); break;\n      case 'sub': this.subtract(); break;\n      case 'mul': this.multiply(); break;\n      case 'div': this.divide(); break;\n      case 'dot': this.dot(); break;\n      case 'sum': this.calculate(); break;\n      default:\n        this.processNumber(operation);\n    }\n  }\n  /**\n   * A handler for mouse up event dispatched from an action button.\n   * When clicking and releasing this removes focus from a button so it won't\n   * be styled like keyboard focus via `:focus` selector.\n   * @param {MouseEvent} e\n   */\n  _mouseUpHandler(e) {\n    e.target.blur();\n  }\n  /**\n   * Adds the add symbol to the queue.\n   * This operation is ignored when there's no previus element.\n   */\n  add() {\n    this._pushSumbol(CalculatorApp.PLUS_SYMBOL);\n  }\n  /**\n   * Adds the minus symbol to the queue.\n   * When unlike other sumbol adding functions this will always add\n   * the symbol to the queue as minus is a negation of a value before it (even\n   * if the value is another minus).\n   */\n  subtract() {\n    const last = this.queue[this.queue.length - 1];\n    if (last === undefined || isNaN(last)) {\n      this.queue[this.queue.length] = CalculatorApp.MINUS_SYMBOL;\n      this.render();\n    } else {\n      this._pushSumbol(CalculatorApp.MINUS_SYMBOL);\n    }\n  }\n  /**\n   * Adds the multiply symbol to the queue.\n   * This operation is ignored when there's no previus element.\n   */\n  multiply() {\n    this._pushSumbol(CalculatorApp.MULTIPLY_SYMBOL);\n  }\n  /**\n   * Adds the divide symbol to the queue.\n   * This operation is ignored when there's no previus element.\n   */\n  divide() {\n    this._pushSumbol(CalculatorApp.DIVIDE_SYMBOL);\n  }\n  /**\n   * Adds \"dot\" (decimal symbol) to the queue.\n   * It performs the following sanity check beforehand:\n   * - If there's no previous element or previous element is not a number then it\n   * adds \"0\" before adding the dot symbol\n   * - If the previous element is already a decimal then the operation is cancelled.\n   */\n  dot() {\n    // If the last element in queue is not a number then push 0 value in front\n    // as this will be fraction of 1.\n    const last = this.queue[this.queue.length - 1];\n    if (last === undefined || isNaN(last)) {\n      this.queue[this.queue.length] = 0;\n    } else if (typeof last === 'string') {\n      // This is already a decimal value which in this app is represented as\n      // string.\n      return;\n    }\n    this._pushSumbol(CalculatorApp.DOT_SYMBOL);\n  }\n  /**\n   * Cancels previous user input.\n   */\n  backspace() {\n    const last = this.queue[this.queue.length - 1];\n    if (last === undefined) {\n      return;\n    }\n    // If it's a symbol then\n    if (isNaN(last)) {\n      this.queue.pop();\n    } else {\n      const int = Number.isInteger(last);\n      let tmp = String(last);\n      if (!tmp || tmp.length === 1) {\n        this.queue.pop();\n      } else {\n        tmp = tmp.substr(0, tmp.length - 1);\n        this.queue[this.queue.length - 1] = int ? Number(tmp) : tmp;\n      }\n    }\n    this.render();\n  }\n  /**\n   * Adds new symbot to the queue and performs some checks beforehand.\n   * If last element in the queue is a symbol then the symbol is replaced by current value.\n   * Otherwise it is being added to the end of the queue.\n   *\n   * Also if the last element is undefined (no previous element) the adding symbol operation\n   * is ignored as there's no point of adding it.\n   * In this case there's no need to inform the user about the error.\n   * @param {String} symbol An operation symbol to append.\n   */\n  _pushSumbol(symbol) {\n    const last = this.queue[this.queue.length - 1];\n    if (last === undefined) {\n      return;\n    }\n    if (isNaN(last)) {\n      this.queue[this.queue.length - 1] = symbol;\n    } else {\n      this.queue[this.queue.length] = symbol;\n    }\n    this.render();\n  }\n  /**\n   * Calculates the value for current queue of arguments and prints the\n   * result in the display.\n   */\n  calculate() {\n    // Make a copy of the array so we can manipulate it's values.\n    const queue = Array.from(this.queue);\n    if (queue.length === 0) {\n      this.opResult.innerText = 0;\n      return;\n    }\n    // Removes any symbol that is at the end of the queue\n    if (isNaN(queue[queue.length - 1])) {\n      queue.pop();\n    }\n    // Again just to be sure\n    if (queue.length === 0) {\n      this.opResult.innerText = 0;\n      return;\n    }\n    // First we are going to get rid of all \"-\" signs and set number value of the\n    // next item in the queue to negative number value.\n    // This way we don't have to carry about negative numbers later on.\n    //\n    // Note, this adds additional layer of complexity to the function as\n    // this is another iteration over the array. It is called the big O or order of function.\n    // With this 3 loops the complexity is O(3n) meaning for n number of elements\n    // in the array each array may iterate over all initial items (3 times together).\n    // The same could have been done in other 2 loops (reducing it to O(2)) by giving more conditions\n    // but for code readibility I decided to split it into 3 loops.\n    for (let i = queue.length - 1; i >= 0; i--) {\n      const current = queue[i];\n      if (current !== CalculatorApp.MINUS_SYMBOL) {\n        continue;\n      }\n      const previous = queue[i - 1];\n      const next = queue[i + 1];\n      queue[i + 1] = -Number(next);\n      if (!isNaN(previous)) {\n        queue[i] = CalculatorApp.PLUS_SYMBOL;\n      } else {\n        queue.splice(i, 1);\n      }\n    }\n\n    // Now, multiply and divide values as this operations have priority.\n    // The function looks for multiply and divide symbols in the queue and\n    // performs the operations between number before an after the symbol.\n    // The result replaces all 3 items in the queue.\n    // Because array length may change during the oprtation we begin to iterate\n    // from the end of the array.\n    for (let i = queue.length - 1; i >= 0; i--) {\n      const current = queue[i];\n      if (current !== CalculatorApp.MULTIPLY_SYMBOL && current !== CalculatorApp.DIVIDE_SYMBOL) {\n        // not interested for now.\n        continue;\n      }\n      let next = queue[i + 1];\n      if (!next && current === CalculatorApp.DIVIDE_SYMBOL) {\n        // Next item can be 0 or can be empty. Anyway, it's an error\n        this._divideByZeroError();\n        return;\n      }\n      const previous = Number(queue[i - 1]);\n      next = Number(next);\n\n      const result = current === CalculatorApp.DIVIDE_SYMBOL ? previous / next : previous * next;\n      queue.splice(i - 1, 3, result);\n    }\n    // At this point the queue contains only sum and minus symbols.\n    // We are iterating over the array again from the end of the array performing +/-\n    // operations until we are left with a single item which is the result\n    for (let i = queue.length - 1; i >= 0; i--) {\n      const current = queue[i];\n      if (current !== CalculatorApp.PLUS_SYMBOL && current !== CalculatorApp.MINUS_SYMBOL) {\n        // it must be a number and we are looking for operators.\n        continue;\n      }\n      const next = Number(queue[i + 1]);\n      const previous = Number(queue[i - 1]);\n      const result = current === CalculatorApp.PLUS_SYMBOL ? previous + next : previous - next;\n      queue.splice(i - 1, 3, result);\n    }\n    // At this point there's only one element in the queue. This is the result\n    // of computation of the value.\n    this.opResult.innerText = queue[0];\n    // Override current queue so the next operation will begin with result of this operation.\n    this.queue = isNaN(queue[0]) ? [] : queue;\n  }\n  /**\n   * Prints an error when the user requested illigal operation of division by zero.\n   * Note, in JavaScript division by 0 results with `Infinity` number.\n   * From the mathematical pov it is incorrect as this operation is just impossible\n   * and cannot return a value. Therefore division by 0 is tested here manually\n   * and the error is then printed.\n   */\n  _divideByZeroError() {\n    this.opResult.innerText = 'Division by zero!';\n  }\n\n  /**\n   * Processses numeric value input.\n   * @param {String|Number} value Numeric value to process\n   */\n  processNumber(value) {\n    // cast to a number just to be sure.\n    value = Number(value);\n    if (value !== value) {\n      console.warn('Passed value is not a number.');\n      return;\n    }\n    // In first step we check if there's a previous element in the queue.\n    // If not, just add the value to the queue.\n    if (!this.queue.length) {\n      this.queue.push(value);\n    } else {\n      // Otherwise we have to deal with previous user input.\n      // In general principle if a previous item is a number then the calculator\n      // needs to concatenate to numbers together (not add!).\n      // It is getting more complicated if the number is a float value. Additional\n      // operations has to be performed (described below).\n      // When the last operation was a \".\" then the calculator also has to deal with fractions.\n      // Finally when the last element in the queue is some other symbol then\n      // current value can be safely added to the queue.\n      let last = this.queue[this.queue.length - 1];\n      if (last === CalculatorApp.DOT_SYMBOL) {\n        // Fractions are a bit of a mess. See description for `_addFraction()`\n        // function for more information.\n        last = this._addFraction(this.queue[this.queue.length - 2], value);\n        // removes the dot from the queue. It is already in the number\n        this.queue.pop();\n        this.queue[this.queue.length - 1] = last;\n      } else if (!isNaN(last)) {\n        if (typeof last === 'string') {\n          // This must be a fraction already.\n          last = this._addFraction(last, value);\n        } else {\n          // Easy, in this case the calculator has to multiply last value by 10\n          // and add current value.\n          // Note, last value cannot be fraction here as fractions were detected earlier.\n          last = last * 10 + value;\n        }\n        this.queue[this.queue.length - 1] = last;\n      } else {\n        // last element is an operator so this is new number.\n        this.queue.push(value);\n      }\n    }\n    // Now it is the time to reflect current state in the UI.\n    this.render();\n  }\n  /**\n   * Managing fractions is a bit tricky in JavaScript.\n   * When the user input \"0\", then \".\" and then \"0\" again, the result in Number\n   * is still single \"0\". Because of that this function converts the number to\n   * a string, appends decimal value to the end of it and returns value as a\n   * string.\n   *\n   * The `sum()` function has to take this into account when processing\n   * the queue.\n   *\n   * @param {String|Number} num Number to add fraction to\n   * @param {String|Number} value Fraction value to add\n   * @return {String}\n   */\n  _addFraction(num, value) {\n    let tmp = String(num);\n    if (tmp.indexOf('.') === -1) {\n      tmp += '.';\n    }\n    tmp += value;\n    return tmp;\n  }\n  /**\n   * Renders current state of values entered by the user in the upper line of\n   * the result display.\n   */\n  render() {\n    let list = '';\n    for (let i = 0, len = this.queue.length; i < len; i++) {\n      const current = this.queue[i];\n      const next = this.queue[i + 1];\n      if (list) {\n        list += ' ';\n      }\n      if (next === CalculatorApp.DOT_SYMBOL) {\n        i++;\n        list += `${current}.${next}`;\n      } else {\n        list += current;\n      }\n    }\n    if (list) {\n      this.partsResult.innerText = list;\n    } else {\n      this.partsResult.innerHTML = '&nbsp;';\n    }\n  }\n  /**\n   * Handles keyboard down event.\n   * Depending on the originating key it performs aoperation on the calculator\n   * usfing defined functions like `add()`, `subtract()` etc.\n   * @param {KeyboardEvent} e\n   */\n  _keyDownHandler(e) {\n    switch (e.key) {\n      case 'Escape':\n        this.clear();\n        break;\n      case '+':\n        this.add();\n        break;\n      case '-':\n        this.subtract();\n        break;\n      case '*':\n        this.multiply();\n        break;\n      case '/':\n        this.divide();\n        break;\n      case '=':\n        this.calculate();\n        break;\n      case '.':\n      case ',':\n        this.dot();\n        break;\n      case 'Backspace':\n        this.backspace();\n        break;\n      default:\n        // Numpad equals sign is the same button as enter. It can be checked using\n        // KeyboardEvent.code property.\n        if (e.code === 'NumpadEnter') {\n          this.calculate();\n          return;\n        }\n        // Numeric kays have number value on KeyboardEvent.key\n        if (!isNaN(e.key)) {\n          this.processNumber(e.key);\n        }\n    }\n  }\n  /**\n   * Clears current result and the queue.\n   */\n  clear() {\n    this.opResult.innerText = '0';\n    this.partsResult.innerHTML = '&nbsp;';\n    this.queue = [];\n  }\n}\nconst app = new CalculatorApp();\napp.init();\n"],"names":["CalculatorApp","this","__partsResult","document","getElementById","__opResult","constructor","_actionHandler","bind","_mouseUpHandler","_keyDownHandler","queue","init","nodes","querySelectorAll","i","len","length","addEventListener","body","e","operation","target","dataset","value","add","subtract","multiply","divide","dot","calculate","processNumber","blur","_pushSumbol","PLUS_SYMBOL","last","undefined","isNaN","MINUS_SYMBOL","render","MULTIPLY_SYMBOL","DIVIDE_SYMBOL","DOT_SYMBOL","backspace","pop","int","Number","isInteger","tmp","String","substr","symbol","Array","from","previous","next","splice","current","_divideByZeroError","result","opResult","innerText","_addFraction","push","console","warn","num","indexOf","list","partsResult","innerHTML","key","clear","code"],"mappings":"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"}